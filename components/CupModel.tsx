/* Auto-generated by: https://github.com/pmndrs/gltfjsx */
import * as THREE from 'three'
import React, { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { GLTF } from 'three-stdlib'
import { useFrame } from "@react-three/fiber";

type GLTFResult = GLTF & {
  nodes: {
    Ceramic_cup_Circle005: THREE.Mesh
    Saucer_Circle006: THREE.Mesh
    Floor_Plane: THREE.Mesh
    ['Light_emission001_Plane004-Mesh']: THREE.Mesh
    ['Light_emission001_Plane004-Mesh_1']: THREE.Mesh
    Circle_Circle009: THREE.Mesh
  }
  materials: {
    Ceramic_cup_colors: THREE.MeshStandardMaterial
    Floor_color: THREE.MeshStandardMaterial
    ['Material.003']: THREE.MeshStandardMaterial
    ['Material.002']: THREE.MeshStandardMaterial
    None: THREE.MeshStandardMaterial
  }
}

export function CupModel(props: {
  groupProps?: JSX.IntrinsicElements["group"],
  noSaucer: boolean
}) {
  const group = useRef<THREE.Group>()
  const { nodes } = useGLTF('/assets/models/CupModel.gltf') as GLTFResult

  return (
    <group ref={group} {...props.groupProps} dispose={null}>
      <mesh geometry={nodes.Ceramic_cup_Circle005.geometry}>
        {/* <meshNormalMaterial /> */}
        <meshPhongMaterial color="#fff" shininess={10} />
      </mesh>
      {
        props.noSaucer ? (
          null
        ) : (
          <mesh geometry={nodes.Saucer_Circle006.geometry}>
            {/* <meshNormalMaterial /> */}
            <meshPhongMaterial color="#fff" shininess={10} />  
          </mesh>
        )
      }
    </group>
  )
}

useGLTF.preload('/assets/models/CupModel.gltf')

export interface CupModelsProps {
  count: number,
  fieldScale: number,
  closeness: number
}

export default function CupModels(props: CupModelsProps) {

  const group = useRef<THREE.Group>()
  // useFrame(({ clock }) => (group.current!.rotation.x = group.current!.rotation.y = group.current!.rotation.z = Math.sin(clock.getElapsedTime()) * 0.3))
  useFrame(({ clock }) => {
    group.current!.rotation.x = clock.getElapsedTime() * 0.1
    group.current!.rotation.y = Math.sin(clock.getElapsedTime() * 0.4)
    group.current!.rotation.z = clock.getElapsedTime() * 0.1
  })


  const cups = new Array(props.count).fill('i').map((el, i) => {
    const xPos = (Math.random() - 0.5) * props.fieldScale;
    const yPos = (Math.random() - 0.5) * props.fieldScale;
    const zPos = (Math.random() - 0.5) * props.fieldScale + props.closeness;

    const xRot = Math.PI * Math.random() * 2 
    const yRot = Math.PI * Math.random() * 2 
    const zRot = Math.PI * Math.random() * 2 

    const sca = Math.random() * 0.2

    const saucerBool = Math.random() < 0.5 ? true : false
    return (<CupModel key={i} noSaucer={saucerBool} groupProps={{position: [xPos, yPos, zPos], rotation: [xRot, yRot, zRot], scale: [sca, sca, sca]}} />)
  })

  return ( 
      <group ref={group}>
        {cups}
      </group>
    )

}